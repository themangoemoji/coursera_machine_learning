%% Creates a model for predicting Access Point (AP) direction from a wifi sensor using Signal Strength (SS)
%%
%% Generates fake training data assuming:
%%   1. Signal degrades with distance (using exponential decay function to simulate)
%%   2. Signal degrades with angle of sensor (using cardiod function to simulate)
%%
%% The data is generated by simulating:
%%      1. Turning our sensor. We use SS measurements from 3 trailing positions. We apply the cardiod function to simulate SS changing based on where we have turned.
%%      2. Choosing random distances between the sensor and AP

%% Performance
%% 1. Scenario: Access Points in Circle Around Sensor 
%%      Median error: ~29 degrees
%% 2. Scenario: Access Points in One General Direction
%%      Median error: ~4 degrees

%% Assumptions
%% 1. Model requires at least 2 access points

%% Further exploration:
%% 1. Extend model to allow for moving sensor in space (toward/away from AP's). This model currently accounts for changing angle of device, not moving in space.
%% 2. Extend training to account for 3D space.
%% 3. Detect different scenarios and dynamically switch models
%% 4. Add polynomial functions of features (create a function of the turns)
%% 4. Automated Tuning of the Model. I chose hardcoded values by hand via experimentation.


% Initialization
clear ; close all; clc

access_points = 4;

% Simulate turning in a circle
turn_speed = pi/((rand(1)+.5) * 16)
start = 0;
position2 = start + turn_speed;
position3 = position2 + turn_speed;
position4 = position3 + turn_speed;
position5 = position4 + turn_speed;
position6 = position5 + turn_speed;
positions = [start position2 position3 ];

X = []; % Collects all signal strengths from data generation
Y = []; % Collects all true directions from data generation

% Training Data Generation Scenario: Access Points in Circle Around Sensor
% Add training data for AP's in circle around origin (sensor)
iterations = 100;
for iteration = 1:iterations,
    % adds APs in every direction around the origin/sensor that are distances in the range of [-2, 2] away
    x_dir = (rand(1, access_points) - 0.5) .* 8;
    y_dir = (rand(1, access_points) - 0.5) .* 8;
    [amplitudes, angles] = get_amplitude(x_dir, y_dir, positions);
    [X, Y, access_points,] = addData(X, Y, amplitudes, access_points, angles);
end

% Training Data Generation Scenario: Access Points in One General Direction
% Add training data for AP's in narrow field of vision
for iteration = 1:iterations,
    % adds APs in every direction around the origin/sensor that are distances in the range of [-2, 2] away
    x_dir = rand(1, access_points) .* 4;
    y_dir = rand(1, access_points) .* 8;
    [amplitudes, angles] = get_amplitude(x_dir, y_dir, positions);
    [X, Y, access_points,] = addData(X, Y, amplitudes, access_points, angles);
end

save signals.dat X
save direction.dat Y

% Some gradient descent settings
theta = zeros(access_points * length(positions) + 1, 1); % Theta for all AP at all positions + bias unit

iterations = 1000;
alpha = 0.0003;

fprintf('\nTesting the cost function ...\n')
% compute and display initial cost
J = computeCostMulti(X, Y, theta);
[theta, jhist] = gradientDescentMulti(X, Y, theta, alpha, iterations);

training_data_guesses = X * theta;
median_error = median(abs(Y - training_data_guesses));

degrees_from_radians_ratio = 360 / (2*pi);
error_in_degrees = degrees_from_radians_ratio * median_error;
fprintf('Median error (in degrees) = %f\n', error_in_degrees);
